## **1. llmGateway: Архитектурное описание**
#### **1.1. Ключевая суть**
README ЧАСТИЧНО УСТАРЕЛ. Программа в процессе разработки. Часть модулей изменила своё название.

`llmGateway` — это высокопроизводительный, асинхронный прокси-сервер и балансировщик нагрузки, созданный для повышения отказоустойчивости при работе с API различных LLM-провайдеров. Его главная задача — объединить множество API-ключей, в том числе нестабильных, в единую, надежную и легко управляемую точку входа.
Проект состоит из двух независимых, но взаимодействующих сущностей:
1.  **Фоновый Воркер ("Хранитель"):** Проактивно проверяет работоспособность ключей и прокси, синхронизирует их с файлами на диске и поддерживает базу данных в актуальном состоянии.
2.  **API Шлюз ("Проводник"):** Реактивно обрабатывает входящие запросы в реальном времени, выбирая для каждого из них наиболее подходящий рабочий ключ и проксируя запрос к целевому API.
### **2. Новая архитектура: Асинхронность и модульность**
Aрхитектура строится на принципах асинхронной обработки, полиморфизма и четкого разделения ответственности. Вся система, от фоновых задач до будущего API-шлюза, спроектирована для неблокирующей работы, что обеспечивает высокую производительность и отзывчивость.
#### **2.1. Структура каталогов**
```
/llmGateway
├── config/
│   └── providers.yaml
├── keys/                       # Каталог для файлов с API-ключами
├── logs/                       # Каталог для файлов логов
├── proxies/                    # Каталог для файлов со списками прокси
├── main.py                     # <-- ИЗМЕНЕН: Теперь управляет новым CLI
├── src/
│   ├── config/                 # Модули для работы с конфигурацией
│   │   ├── **init**.py           # <-- НОВЫЙ: Фасад пакета, реализует синглтон
│   │   ├── defaults.py         # Модуль со значениями по-умолчанию для глобальных настроек
│   │   ├── loader.py             # <-- ИЗМЕНЕН: Теперь "умный" сборщик конфига
│   │   ├── logging_config.py   # Модуль для настройки системы логирования
│   │   ├── provider_templates.py # Централизованный словарь с уникальными атрибутами провайдеров
│   │   ├── schemas.py            # <-- ИЗМЕНЕН: Теперь строгий "контракт" и источник правды
│   │   └── validator.py          # <-- НОВЫЙ: Отдельный валидатор бизнес-логики
│   ├── core/                   # Универсальное ядро (абстракции, модели, контракты)
│   │   ├── accessor.py           # <-- НОВЫЙ: Безопасный фасад для доступа к конфигу
│   │   ├── enums.py            # Стандартизированные перечисления (например, ErrorReason)
│   │   ├── http_client_factory.py # Фабрика для создания и управления HTTP-клиентами
│   │   ├── models.py           # Базовые модели данных (например, CheckResult)
│   │   ├── probes.py           # Абстрактный базовый класс IResourceProbe
│   │   └── types.py            # Интерфейсы (IProvider, IResourceSyncer)
│   ├── db/
│   │   └── database.py         # Слой для работы с базой данных PostgreSQL
│   ├── providers/              # Логика, специфичная для ТИПОВ провайдеров
│   │   ├── **init**.py         # Фабрика для создания инстансов провайдеров
│   │   ├── base.py             # Абстрактный базовый класс AIBaseProvider
│   │   └── impl/               # Конкретные реализации
│   │       ├── deepseek.py     # Реализация для DeepSeek (наследуется от openai_like)
│   │       ├── gemini.py       # Реализация для Gemini (текст/картинки)
│   │       ├── gemini_base.py  # Общий базовый класс для всех API Google
│   │       └── openai_like.py  # Реализация для OpenAI-совместимых API
│   └── services/               # Сервисы и основная бизнес-логика
│       ├── background_worker.py  # Оркестратор фоновых задач (Воркер)
│       ├── config_manager.py     # <-- ИЗМЕНЕН: Поддержка --full и нового синтаксиса
│       ├── gateway_service.py    # Сервис шлюза (API-сервер)
│       ├── maintenance.py        # Сервисы для обслуживания БД (амнистия, VACUUM)
│       ├── statistics_logger.py  # Сервис для сбора и записи статистики
│       ├── circuit_breaker/      # Модуль для реализации паттерна "Предохранитель"
│       │   ├── **init**.py       # Фабрика для создания стратегий предохранителя
│       │   ├── base.py           # Абстрактный базовый класс (контракт) ICircuitBreakerStrategy
│       │   └── impl/             # Конкретные реализации стратегий
│       │       ├── auto_recovery.py  # Реализация стратегии автоматического восстановления
│       │       └── manual_reset.py   # Реализация стратегии ручного сброса
│       ├── probes/               # "Зонды" для активной проверки ресурсов
│       │   ├── **init**.py       # Фабрика для создания инстансов зондов
│       │   └── key_probe.py      # Фоновый сервис-зонд для тестирования ключей
│       └── synchronizers/        # Синхронизаторы для чтения ресурсов с диска в БД
│           ├── **init**.py       # Фабрика для создания инстансов синхронизаторов
│           ├── key_sync.py       # Синхронизатор API-ключей
│           └── proxy_sync.py     # Синхронизатор списков прокси
│
└── pyproject.toml
```
### **3. Ключевые концепции**
#### **3.1. Два режима работы: "Хранитель" и "Проводник"**
1.  **Режим "Хранителя" (Фоновый Воркер):** Это проактивная фоновая служба, запускаемая через `python main.py worker` [1]. Специализированные "зонды" (например, `key_probe.py`) асинхронно и конкурентно опрашивают базу данных, отправляют тестовые запросы и обновляют статусы ресурсов. Этот режим гарантирует, что система всегда имеет актуальное представление о здоровье своего пула ключей и прокси.
2.  **Режим "Проводника" (API Шлюз):** Это реактивная служба, которая будет реализована на базе **FastAPI** и **Uvicorn**. Она будет асинхронно обрабатывать сотни одновременных запросов, запрашивать у базы данных уже проверенный, валидный ресурс, проксировать запрос к целевому API и немедленно обновлять статус использованного ресурса в базе данных.
#### **3.2. Новая система конфигурации: Контракт, Сборка, Валидация и Доступ**
Мы полностью отказались от "монструозных" конфигов в пользу гибкой, многоуровневой и декларативной системы. Пользовательский `providers.yaml` теперь является не полным описанием системы, а **"патчем"** — набором инструкций, которые переопределяют стандартное поведение. Эта система стоит на четырех китах:
1.  **Контракт `schemas.py`):** Это железобетонный фундамент и **единственный источник правды**. Все возможные параметры, их типы и значения по умолчанию определены здесь в виде строго типизированных датаклассов. Если поля нет в YAML, его значение будет взято отсюда.
2.  **Сборщик `loader.py`):** Это "умный" сборщик, который работает во время запуска приложения. Он берет минималистичный пользовательский YAML, рекурсивно сливает его с дефолтами из `schemas.py` и шаблонами из `provider_templates.py` [4] и строит в памяти **полный, непротиворечивый объект конфигурации**. Он также отвечает за подстановку секретов из `.env` файлов [5].
3.  **Валидатор `validator.py`):** Это "контролер ОТК". Он получает уже полностью собранный объект от `loader`-а и проверяет его на соответствие бизнес-логике: уникальность токенов, целостность связей между моделями, корректность режимов работы и т.д. В отличие от старой версии, он накапливает все ошибки и выдает их единым списком, что дико удобно для отладки.
4.  **Фасад `accessor.py`):** Это безопасный и удобный интерфейс доступа к конфигурации для остального приложения. Вместо того чтобы лазить по вложенной структуре `config.providers['...'].health_policy...`), код использует простые и понятные методы `accessor.get_health_policy('...')`). Это полностью отвязывает бизнес-логику от структуры YAML-файла.
**Управление через CLI `config_manager.py`):**
Для управления конфигурацией используется мощный CLI-интерфейс [5], который теперь поддерживает два режима:
   `python main.py config create <type>:<name>`_: Создает_ _минимальный_* конфиг, добавляя в YAML только уникальные и обязательные поля. Это сохраняет файл чистым и читаемым.
   `python main.py config create --full <type>:<name>`_: Создает_ _полный_* конфиг, явно прописывая в файл все возможные настройки из дефолтов [2]. Идеально для продвинутых пользователей, которые хотят видеть и тюнинговать каждый параметр.
#### **3.3. Гранулярное отслеживание статуса в БД**
Ключевое улучшение — это переход на **клиент-серверную СУБД PostgreSQL**, которая обеспечивает высокую производительность при конкурентном доступе. Слой доступа к данным `database.py` инкапсулирует всю логику работы с БД. Система отслеживает статус для каждой уникальной пары **"провайдер-ключ-модель"**, что позволяет максимально эффективно использовать каждый ключ.
#### **3.4. НЕ РЕАЛИЗОВАНО! Политики отказоустойчивости Шлюза (Retry и Circuit Breaker)**
Для обеспечения высокой надежности в режиме "Проводника" реализованы две настраиваемые политики:
1.  **Политика переотправки (Retry):** Для каждого инстанса можно настроить автоматическую переотправку запросов.
2.  **Механизм "Предохранитель" (Circuit Breaker):** Это защитный паттерн, предотвращающий каскадные сбои.
#### **3.5. Централизованное управление HTTP-клиентами `HttpClientFactory`)**
Ключевым архитектурным изменением стал отказ от одного глобального HTTP-клиента в пользу централизованной **фабрики клиентов `http_client_factory.py`)**. Этот подход позволяет системе эффективно работать с различными конфигурациями сети (прямое подключение, статический прокси) одновременно, создавая и кэшируя преднастроенные экземпляры `httpx.AsyncClient`.

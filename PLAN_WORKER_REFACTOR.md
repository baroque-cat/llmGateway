# План рефакторинга: Background Worker (Хранитель)

**Цель**: Внедрить строгую верификацию ошибок с длинными паузами. Воркер не должен блокироваться на ожидании.

## 1. Обновление конфигурации (`src/config/schemas.py`)

- [x] Добавить в `HealthPolicyConfig`:
- [x] `verification_attempts`: int (по умолчанию 3) — сколько раз перепроверять.
- [x] `verification_delay_sec`: int (по умолчанию 65) — жесткая пауза между попытками. Выбрана > 60 сек, чтобы гарантированно пережить минутные rate limits.

## 2. Рефакторинг логики (`src/services/background_worker.py`)

### 2.1. Асинхронная архитектура
- [x] Воркер уже работает на `asyncio`. При реализации паузы использовать `await asyncio.sleep(delay)`, что позволит event loop переключаться на обработку других задач. Отдельный кэш состояния не нужен.

### 2.2. Алгоритм проверки (`KeyProbe.check_key`)

1. **Мгновенный приговор (Fast Fail)**:
   - [x] Если `result.error_reason.is_fatal()` (напр. `INVALID_KEY`) → **Пенальти** сразу.
   - [x] Обновить статус в БД, верификацию не запускать.

2. **Цикл Верификации (Verification Loop)**:
   - [x] Если `result.error_reason.is_retryable()` (напр. `RATE_LIMITED`, `SERVER_ERROR`):
     - [x] Запустить цикл (от 0 до `verification_attempts`):
       - [x] **Пауза**: `await asyncio.sleep(verification_delay_sec)` (65 сек).
       - [x] **Повторный запрос**.
       - [x] **Анализ ответа**:
         - [x] `VALID` (200) → Успех. Выход из цикла, обновление `last_used`. Ключ спасен.
         - [x] `FATAL` (401) → Провал. Мгновенное пенальти. Выход.
         - [x] `RETRYABLE` (429/500) → Продолжить цикл.
     - [x] **Финал**: Если попытки исчерпаны, а статус всё еще плохой → **Пенальти** по последнему полученному статусу.

## 3. Тестирование
- [x] Тесты на длительное ожидание (с использованием `mock_sleep`, чтобы не ждать реально 65 сек).
- [x] Проверка сценариев восстановления (500 -> 500 -> 200).
- [x] Проверка сценария подтверждения смерти (429 -> 429 -> 429 -> Пенальти).
